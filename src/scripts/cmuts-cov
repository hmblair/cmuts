#!/usr/bin/env python3

import h5py
import dask.array as da
import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
from cov import (
    probability,
    mutual_information,
    zero_diag,
    cooccurrence,
    conditional,
    covariance,
    correlation,
    cooccurrence,
)
from mpl_toolkits.mplot3d import Axes3D

BOLD = '\033[1m'
RESET = '\033[0m'
CMAP = "RdPu"

with open(f"{os.path.dirname(os.path.abspath(__file__))}/VERSION", "r") as f:
    VERSION = f.read().strip()

NAME = 'cmuts-cov'
PBAR_WIDTH = 20
FIGURES = "figures"

IX_DEL = 4
IX_INS = 5
IX_TERM = 6

parser = argparse.ArgumentParser()
parser.add_argument(
    'file',
    help='The HDF5 file containing the input data.',
)
parser.add_argument(
    '--dataset',
    help='The name of the dataset containing the mutation counts of the modified sequences.',
    required=True,
)
parser.add_argument(
    '-o', '--output',
    help='The output HDF5 file to write to.',
    default='cov.h5'
)
parser.add_argument(
    '--overwrite',
    help='Overwrite an existing HDF5 file (the whole file, not just the group).',
    action='store_true',
)
parser.add_argument(
    '--cooccurrence',
    help='Compute the cooccurrence probability of residues in each read.',
    action="store_true",
)
parser.add_argument(
    '--conditional',
    help='Compute conditional modification probabilities across residues.',
    action="store_true",
)
parser.add_argument(
    '--correlation',
    help='Compute modification correlations across residues.',
    action="store_true",
)
parser.add_argument(
    '--mutual-information',
    help='Compute the mutual information between pairs of residues.',
    action="store_true",
)
parser.add_argument(
    '--zero-diag',
    help='Zero the diagonal in the relevant outputs, for better visualization.',
    action="store_true",
)
parser.add_argument(
    '--trim-5p',
    help='Trim this many residues from the 5\' end.',
    type=int,
    default=0,
)
parser.add_argument(
    '--trim-3p',
    help='Trim this many residues from the 3\' end.',
    type=int,
    default=0,
)


def _title(program: str, version: str, name: str) -> str:
    return f"""        {program} version {version}
      ───────────────────────────────────
        {BOLD}Statistics for {name}:{RESET}"""


def _remove_if_exists(
    path: str,
    overwrite: bool = False
) -> None:
    if os.path.exists(path):
        if overwrite:
            os.remove(path)


def _get_coords(x: np.ndarray) -> np.ndarray:

    n = x.shape[0]

    H = np.eye(n) - np.ones((n, n)) / n
    B = -0.5 * H @ x @ H

    eigenvals, eigenvecs = np.linalg.eigh(B)

    idx = np.argsort(eigenvals)[::-1]
    eigenvals = eigenvals[idx]
    eigenvecs = eigenvecs[:, idx]

    eigenvals_3d = np.maximum(eigenvals[:3], 0)
    coords_3d = eigenvecs[:, :3] @ np.diag(np.sqrt(eigenvals_3d))

    return coords_3d


def plot_3d_coords(coords: np.ndarray, labels=None, title="3D Coordinates"):

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Extract x, y, z coordinates
    x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]

    # Create scatter plot
    scatter = ax.scatter(x, y, z, c=range(len(coords)), cmap='viridis', s=50)

    # Add labels if provided
    if labels is not None:
        for i, label in enumerate(labels):
            ax.text(x[i], y[i], z[i], str(label), fontsize=8)

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title(title)

    plt.colorbar(scatter)
    plt.show()


def _plot_cooccurrence(data: np.ndarray, name: str) -> np.ndarray:

    vals = cooccurrence(data)

    min = vals.max() / 2
    max = vals.max()
    norm = LogNorm(vmin=min, vmax=max)

    im = plt.imshow(vals, cmap=CMAP, norm=norm)
    plt.colorbar(im, label="Co-Occurrence")
    plt.xlabel("Residue", fontsize=13)
    plt.ylabel("Residue", fontsize=13)
    plt.savefig(f"figures/{name}-cooccurrence.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


def _plot_conditional(data: np.ndarray, name: str, zero: bool) -> np.ndarray:

    vals = conditional(data)
    if zero:
        vals = zero_diag(vals)

    low = 1E-3
    high = vals.max() / 2
    norm = LogNorm(vmin=low, vmax=high)

    im = plt.imshow(vals, cmap=CMAP, norm=norm)
    plt.colorbar(im, label="Conditional")

    plt.xlabel("Residue", fontsize=13)
    plt.ylabel("Residue", fontsize=13)
    plt.savefig(f"figures/{name}-conditional.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


def _plot_correlation(data: np.ndarray, name: str, zero: bool) -> np.ndarray:

    vals = correlation(data)
    if zero:
        vals = zero_diag(vals)

    low = 1E-6
    high = vals.max() / 2
    norm = LogNorm(vmin=low, vmax=high)

    im = plt.imshow(vals, cmap=CMAP, norm=norm)
    plt.colorbar(im, label="Correlation")

    plt.xlabel("Residue", fontsize=13)
    plt.ylabel("Residue", fontsize=13)
    plt.savefig(f"figures/{name}-correlation.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


def _plot_mi(data: np.ndarray, name: str, zero: bool) -> np.ndarray:

    vals = mutual_information(data)
    if zero:
        vals = zero_diag(vals)

    low = 1E-6
    high = vals.max() / 2
    norm = LogNorm(vmin=low, vmax=high)

    im = plt.imshow(vals, cmap=CMAP, norm=norm)
    plt.colorbar(im, label="Mutual Information")

    plt.xlabel("Residue", fontsize=13)
    plt.ylabel("Residue", fontsize=13)
    plt.savefig(f"figures/{name}-mi.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


if __name__ == '__main__':

    args = parser.parse_args()
    name = args.dataset.split('/')[-1]
    print(_title(NAME, VERSION, name))

    _remove_if_exists(args.output, args.overwrite)

    with h5py.File(args.file, 'r') as f:

        data = f[args.dataset]
        if data.shape[0] > 1:
            raise ValueError("For now, cmuts-cov can only handle 1 datapoint at a time.")
        data = data[0]


        low = args.trim_5p
        high = data.shape[1] - args.trim_3p
        data = data[low:high, low:high]

        out = {}

        if args.cooccurrence:
            vals = _plot_cooccurrence(data, name)
            out["cooccurrence"] = da.from_array(vals)
        if args.conditional:
            vals = _plot_conditional(data, name, args.zero_diag)
            out["conditional"] = da.from_array(vals)
        if args.correlation:
            vals = _plot_correlation(data, name, args.zero_diag)
            out["correlation"] = da.from_array(vals)
        if args.mutual_information:
            vals = _plot_mi(data, name, args.zero_diag)
            out["mi"] = da.from_array(vals)

        if out:
            da.to_hdf5(args.output, out)
