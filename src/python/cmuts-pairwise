#!/usr/bin/env python3

import h5py
import dask.array as da
import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import SymLogNorm, LogNorm
from cov import (
    probability,
    mutual_information,
    zero_diag,
    cooccurrence,
    conditional,
    covariance,
    correlation,
    cooccurrence,
)

# Set the font for plotting

plt.rcParams['font.family'] = 'Helvetica'


BOLD = '\033[1m'
RESET = '\033[0m'
CMAP = "RdPu"

with open(f"{os.path.dirname(os.path.abspath(__file__))}/VERSION", "r") as f:
    VERSION = f.read().strip()

NAME = 'cmuts pairwise'
PBAR_WIDTH = 20
FIGURES = "figures"

IX_DEL = 4
IX_INS = 5
IX_TERM = 6

parser = argparse.ArgumentParser()
parser.add_argument(
    'file',
    help='The HDF5 file containing the input data.',
)
parser.add_argument(
    '--mod',
    help='The name of the dataset containing the mutation counts of the modified sequences.',
    required=True,
)
parser.add_argument(
    '--nomod',
    help='The name of the dataset containing the mutation counts of the modified sequences.',
)
parser.add_argument(
    '--name',
    help='The name of the dataset containing the mutation counts of the modified sequences.',
    required=True,
)
parser.add_argument(
    '-o', '--output',
    help='The output HDF5 file to write to.',
    default='cov.h5'
)
parser.add_argument(
    '--overwrite',
    help='Overwrite an existing HDF5 file (the whole file, not just the group).',
    action='store_true',
)
parser.add_argument(
    '--cooccurrence',
    help='Compute the cooccurrence probability of residues in each read.',
    action="store_true",
)
parser.add_argument(
    '--conditional',
    help='Compute conditional modification probabilities across residues.',
    action="store_true",
)
parser.add_argument(
    '--correlation',
    help='Compute modification correlations across residues.',
    action="store_true",
)
parser.add_argument(
    '--mutual-information',
    help='Compute the mutual information between pairs of residues.',
    action="store_true",
)
parser.add_argument(
    '--zero-diag',
    help='Zero the diagonal in the relevant outputs, for better visualization.',
    nargs='?',
    const=1,
    default=0,
    type=int,
)
parser.add_argument(
    '--low-rank',
    type=int,
    default=0,
)
parser.add_argument(
    '--trim-5p',
    help='Trim this many residues from the 5\' end.',
    type=int,
    default=0,
)
parser.add_argument(
    '--trim-3p',
    help='Trim this many residues from the 3\' end.',
    type=int,
    default=0,
)


def _title(program: str, version: str, name: str) -> str:
    return f"""        {program} version {version}
      ───────────────────────────────────
        {BOLD}Statistics for {name}:{RESET}"""


def _remove_if_exists(
    path: str,
    overwrite: bool = False
) -> None:
    if os.path.exists(path):
        if overwrite:
            os.remove(path)


def _get_coords(x: np.ndarray) -> np.ndarray:

    n = x.shape[0]

    H = np.eye(n) - np.ones((n, n)) / n
    B = -0.5 * H @ x @ H

    eigenvals, eigenvecs = np.linalg.eigh(B)

    idx = np.argsort(eigenvals)[::-1]
    eigenvals = eigenvals[idx]
    eigenvecs = eigenvecs[:, idx]

    eigenvals_3d = np.maximum(eigenvals[:3], 0)
    coords_3d = eigenvecs[:, :3] @ np.diag(np.sqrt(eigenvals_3d))

    return coords_3d


def plot_3d_coords(coords: np.ndarray, labels=None, title="3D Coordinates"):

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Extract x, y, z coordinates
    x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]

    # Create scatter plot
    scatter = ax.scatter(x, y, z, c=range(len(coords)), cmap='viridis', s=50)

    # Add labels if provided
    if labels is not None:
        for i, label in enumerate(labels):
            ax.text(x[i], y[i], z[i], str(label), fontsize=8)

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title(title)

    plt.colorbar(scatter)
    plt.show()


def _trim_rank(data: np.ndarray, low: int = 0, high: int = 1) -> np.ndarray:

    U, S, Vh = np.linalg.svd(data)
    return U[:, low:-high] @ np.diag(S[low:-high]) @ Vh[low:-high, :]


def _fft_denoise(signal: np.ndarray, threshold: int = 0.05) -> np.ndarray:

    fft = np.fft.fft2(signal)
    magnitude = np.abs(fft)
    max_magnitude = np.max(magnitude)

    mask = magnitude > threshold * max_magnitude
    fft_denoised = fft * mask

    return np.real(np.fft.ifft2(fft_denoised)).astype(np.float32)


def _plot_cooccurrence(
    mod: np.ndarray,
    nomod: np.ndarray | None,
    mask: np.ndarray,
    name: str,
) -> np.ndarray:

    if nomod is not None:
        vals = cooccurrence(mod + nomod)
    else:
        vals = cooccurrence(mod)

    min = vals[mask].max() / 2
    max = vals[mask].max()

    im = plt.imshow(vals, cmap=CMAP, vmin=min, vmax=max)
    plt.colorbar(im, label="Co-Occurrence")

    plt.xlabel("Residue", fontsize=14)
    plt.ylabel("Residue", fontsize=14)
    plt.tick_params(axis='both', labelsize=13)
    plt.savefig(f"{FIGURES}/{name}-cooccurrence.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


def _plot_conditional(
    mod: np.ndarray,
    nomod: np.ndarray | None,
    mask: np.ndarray,
    name: str,
    low: int,
    high: int,
    zero: int,
) -> np.ndarray:

    vals = conditional(mod)
    if nomod is not None:
        vals -= conditional(nomod)
    if zero:
        vals = zero_diag(vals, zero)

    vlow = 1E-3
    vhigh = vals[mask].max() / 2
    norm = LogNorm(vmin=vlow, vmax=vhigh)

    im = plt.imshow(vals, cmap=CMAP, norm=norm, extent=[low, high, low, high])
    cbar = plt.colorbar(im)
    cbar.set_label("Conditional", fontsize=14)
    cbar.ax.tick_params(labelsize=13)

    plt.title(f"Conditional probability ({name})")
    plt.xlabel("Residue", fontsize=14)
    plt.ylabel("Residue", fontsize=14)
    plt.tick_params(axis='both', labelsize=13)
    plt.savefig(f"{FIGURES}/{name}-conditional.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


def _plot_correlation(
    mod: np.ndarray,
    nomod: np.ndarray | None,
    mask: np.ndarray,
    name: str,
    low: int,
    high: int,
    zero: int,
    rank: int = 0,
) -> np.ndarray:

    vals = correlation(mod, nomod)

    if zero:
        vals = zero_diag(vals, zero)
    if rank: 
        vals = _trim_rank(vals, rank)

    vlow = -vals[mask].max() / 2
    vhigh = vals[mask].max() / 2
    linthresh = vhigh * 1E-2
    norm = SymLogNorm(linthresh=linthresh, vmin=vlow, vmax=vhigh)

    im = plt.imshow(vals, cmap='PiYG', norm=norm, extent=[low, high, low, high])
    cbar = plt.colorbar(im)
    cbar.set_label("Correlation", fontsize=14)
    cbar.ax.tick_params(labelsize=13)

    plt.title(f"Correlation ({name})")
    plt.xlabel("Residue", fontsize=14)
    plt.ylabel("Residue", fontsize=14)
    plt.tick_params(axis='both', labelsize=13)
    plt.savefig(f"{FIGURES}/{name}-correlation.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


def _plot_mi(
    mod: np.ndarray,
    nomod: np.ndarray | None,
    mask: np.ndarray,
    name: str,
    low: int,
    high: int,
    zero: int,
    rank: int = 0,
) -> np.ndarray:

    vals = mutual_information(mod)
    if nomod is not None:
        vals -= mutual_information(nomod)

    if zero:
        vals = zero_diag(vals, zero)
    if rank: 
        vals = _trim_rank(vals, rank)

    vlow = 1E-6
    vhigh = vals[mask].max() / 2
    norm = LogNorm(vmin=vlow, vmax=vhigh)

    im = plt.imshow(vals, cmap=CMAP, norm=norm, extent=[low, high, low, high])
    cbar = plt.colorbar(im)
    cbar.set_label("Mutual Information", fontsize=14)
    cbar.ax.tick_params(labelsize=13)

    plt.title(f"Mutual Information ({name})")
    plt.xlabel("Residue", fontsize=14)
    plt.ylabel("Residue", fontsize=14)
    plt.tick_params(axis='both', labelsize=13)
    plt.savefig(f"{FIGURES}/{name}-mi.png", dpi=300, bbox_inches="tight")
    plt.close()

    return vals


if __name__ == '__main__':

    args = parser.parse_args()
    name = args.name.split('/')[-1]
    print(_title(NAME, VERSION, name))

    _remove_if_exists(args.output, args.overwrite)

    with h5py.File(args.file, 'r') as f:

        mod = f[args.mod]
        if mod.shape[0] > 1:
            raise ValueError("For now, cmuts pairwise can only handle 1 datapoint at a time.")
        mod = mod[0]
        
        if args.nomod:
            nomod = f[args.nomod]
            nomod = nomod[0]
        else:
            nomod = None

    low = args.trim_5p
    high = mod.shape[1] - args.trim_3p

    mod[:low, :] = np.nan
    mod[high:, :] = np.nan
    mod[:, :low] = np.nan
    mod[:, high:] = np.nan
    if nomod is not None:
        nomod[:low, :] = np.nan
        nomod[high:, :] = np.nan
        nomod[:, :low] = np.nan
        nomod[:, high:] = np.nan
    mask = np.any(~np.isnan(mod), axis=(-2, -1))

    out = {}
    os.makedirs(FIGURES, exist_ok=True)

    if args.cooccurrence:
        vals = _plot_cooccurrence(mod, nomod, mask, name)
        out[name + "/" + "cooccurrence"] = da.from_array(vals)
    if args.conditional:
        vals = _plot_conditional(mod, nomod, mask, name, low, high, args.zero_diag)
        out[name + "/" + "conditional"] = da.from_array(vals)
    if args.correlation:
        vals = _plot_correlation(mod, nomod, mask, name, low, high, args.zero_diag, args.low_rank)
        out[name + "/" + "correlation"] = da.from_array(vals)
    if args.mutual_information:
        vals = _plot_mi(mod, nomod, mask, name, low, high, args.zero_diag, args.low_rank)
        out[name + "/" + "mi"] = da.from_array(vals)

    if out:
        da.to_hdf5(args.output, out)
